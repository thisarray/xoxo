<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tic Tac Toe</title>
  <style type="text/css" media="screen">
body {
  background-color: white;
  color: black;
}
output {
  display: block;
  margin-bottom: 1em;
  margin-left: 1em;
}
pre {
  font-family: "Courier New", monospace;
  font-size: 40px;
  line-height: 40px;
  text-transform: full-width;
}
table {
  border-collapse: collapse;
  font-size: 36px;
  line-height: 36px;
  margin: 0;
  padding: 0;
  text-align: center;
}
td {
  background-color: white;
  border: 1px solid black;
  color: black;
  height: 38px;
  width: 38px;
}
.O {
  color: red;
}
.X {
  color: blue;
}
  </style>
</head>

<body>

<main>
<h1>Tic Tac Toe</h1>

<p><label for="size">Size:</label> <input type="number" id="size" name="size" value="3" min="3"></p>

<output id="board"></output>
<p id="marker"></p>
<button id="new">New board</button>

<p>Connect markers in a row, a column, or a diagonal.</p>
</main>

<script>
/*
 * Size in pixels of each square.
 */
const SCALE = 40;

const X_MARKER = 'X';
const O_MARKER = 'O';
const BLANK_MARKER = ' ';
const TEST_MARKER = '?';

class Board {
  constructor(width, height, length, player, computer) {
    this.width = Math.max(1, width);
    this.height = Math.max(1, height);
    this.cells = BLANK_MARKER.repeat(this.width * this.height);

    this.length = Math.max(2, length);
    this.playerMarker = player;
    this.computerMarker = computer;
    this.playerWinCondition = this.playerMarker.repeat(this.length);
    this.computerWinCondition = this.computerMarker.repeat(this.length);

    this.playerWin = false;
    this.computerWin = false;
    this.done = false;
  }
  coordinatesToIndex(x, y) {
    return x + (y * this.width);
  }
  get(x, y) {
    if (x < 0) {
      return BLANK_MARKER;
    }
    if (y < 0) {
      return BLANK_MARKER;
    }
    if (x >= this.width) {
      return BLANK_MARKER;
    }
    if (y >= this.height) {
      return BLANK_MARKER;
    }
    return this.cells.charAt(this.coordinatesToIndex(x, y));
  }
  get rows() {
    let rows = [];
    for (let i = 0; i < this.cells.length; i += this.width) {
      rows.push(this.cells.substring(i, i + this.width).toUpperCase());
    }
    return rows;
  }
  get columns() {
    let columns = [];
    for (let x = 0; x < this.width; x++) {
      let column = [];
      for (let y = 0; y < this.height; y++) {
        column.push(this.get(x, y));
      }
      columns.push(column.join('').toUpperCase());
    }
    return columns;
  }

  /*
   * Return the diagonal containing the square at (x, y).
   *
   * Defaults to the diagonal going to the bottom right.
   * If toLeft is true, then return the diagonal going to the bottom left.
   */
  getDiagonal(x, y, toLeft = false) {
    let limit = Math.min(this.width, this.height),
        startX = 0,
        startY = 0;
    if (y <= 0) {
      startX = x;
    }
    else {
      if (toLeft) {
        if (x >= (this.width - 1)) {
          startX = this.width - 1;
          startY = y;
        }
        else {
          let delta = Math.min(this.width - 1 - x, y);
          startX = x + delta;
          startY = y - delta;
        }
      }
      else {
        if (x <= 0) {
          startX = 0;
          startY = y;
        }
        else {
          let delta = Math.min(x, y);
          startX = x - delta;
          startY = y - delta;
        }
      }
    }

    let buffer = [],
        currentX = 0,
        currentY = 0;
    for (let i = 0; i < limit; i++) {
      if (toLeft) {
        currentX = startX - i;
      }
      else {
        currentX = startX + i;
      }
      currentY = startY + i;

      if (currentX < 0) {
        break;
      }
      if (currentY < 0) {
        break;
      }
      if (currentX >= this.width) {
        break;
      }
      if (currentY >= this.height) {
        break;
      }
      buffer.push(this.get(currentX, currentY));
    }
    return buffer.join('').toUpperCase();
  }

  mark(x, y, computer = false) {
    if (x < 0) {
      return this;
    }
    if (y < 0) {
      return this;
    }
    if (x >= this.width) {
      return this;
    }
    if (y >= this.height) {
      return this;
    }
    if (this.done) {
      return this;
    }

    let board = new Board(this.width, this.height, this.length, this.playerMarker, this.computerMarker),
        index = this.coordinatesToIndex(x, y),
        marker = this.playerMarker;
    if (computer) {
      marker = this.computerMarker;
    }

    if (this.cells.charAt(index) == BLANK_MARKER) {
      board.cells = Board.replaceCharAt(this.cells, index, marker);
    }
    else {
      return this;
    }

    let directions = board.rows.concat(board.columns);
    // Check the diagonals
    for (let x = 0; x < board.width; x++) {
      directions.push(board.getDiagonal(x, 0));
      directions.push(board.getDiagonal(x, 0, true));
    }
    for (let y = 1; y < board.height; y++) {
      directions.push(board.getDiagonal(0, y));
      directions.push(board.getDiagonal(board.width - 1, y, true));
    }
    for (let direction of directions) {
      if (direction.includes(board.playerWinCondition)) {
        board.playerWin = true;
      }
      if (direction.includes(board.computerWinCondition)) {
        board.computerWin = true;
      }
    }

    // Check if the player or the computer won or if any more moves are possible
    board.done = board.playerWin || board.computerWin || (!board.cells.includes(BLANK_MARKER));

    return board;
  }
  score(x, y) {
    if (x < 0) {
      return 0;
    }
    if (y < 0) {
      return 0;
    }
    if (x >= this.width) {
      return 0;
    }
    if (y >= this.height) {
      return 0;
    }
    if (this.get(x, y) != BLANK_MARKER) {
      return 0;
    }

    let directions = [],
        score = 0;
    directions.push(Board.replaceCharAt(this.rows[y], x, TEST_MARKER));
    directions.push(Board.replaceCharAt(this.columns[x], y, TEST_MARKER));
    directions.push(Board.replaceCharAt(this.getDiagonal(x, y), Math.min(x, y), TEST_MARKER));
    directions.push(Board.replaceCharAt(this.getDiagonal(x, y, true), Math.min(this.width - 1 - x, y), TEST_MARKER));

    for (let direction of directions) {
      let computerTake = direction.replace(TEST_MARKER, this.computerMarker),
          playerTake = direction.replace(TEST_MARKER, this.playerMarker);
      //console.log(x, y, '"' + direction + '"');

      if (computerTake.includes(this.computerWinCondition)) {
        // If taking the spot results in a win, then prioritize this spot
        score += 1000;
      }
      if (playerTake.includes(this.playerWinCondition)) {
        // If the player taking the spot results in a win, then block it
        score += 100;
      }
      if (direction.includes(this.playerMarker)) {
        if (!direction.includes(this.computerMarker)) {
          score += 1;
        }
      }
      else {
        if (direction.length >= this.length) {
          if (direction.includes(this.computerMarker)) {
            // Try to continue runs
            score += 10;
          }
          else {
            // Start a run that is not blocked
            score += 2;
          }
        }
      }
    }

    return score;
  }
  computerMove() {
    if (this.done) {
      return this;
    }

    let scores = [];
    for (let x = 0; x < this.width; x++) {
      for (let y = 0; y < this.height; y++) {
        if (this.get(x, y) == BLANK_MARKER) {
          scores.push({x: x, y: y, score: this.score(x, y)});
        }
      }
    }
    // Sort descending by score
    scores.sort((a, b) => -(a.score - b.score));
    return this.mark(scores[0].x, scores[0].y, true);
  }


  /*
   * Replace the character at str[index] with replacement.
   */
  static replaceCharAt(str, index, replacement) {
    if (index < 0) {
      return str;
    }
    if (str.length <= index) {
      return str;
    }
    if (replacement.length > 1) {
      replacement = replacement.substring(0, 1);
    }
    return str.substring(0, index) + replacement + str.substring(index + 1);
  }

  /*
   * A short test suite to confirm the Board class works.
   */
  static test() {
    console.assert(Board.replaceCharAt('foo', -1, 'F') == 'foo',
                   {msg: 'Board.replaceCharAt() is incorrect.'});
    console.assert(Board.replaceCharAt('foo', 3, 'F') == 'foo',
                   {msg: 'Board.replaceCharAt() is incorrect.'});
    console.assert(Board.replaceCharAt('foo', 0, 'F') == 'Foo',
                   {msg: 'Board.replaceCharAt() is incorrect.'});
    console.assert(Board.replaceCharAt('foo', 0, 'b') == 'boo',
                   {msg: 'Board.replaceCharAt() is incorrect.'});
    console.assert(Board.replaceCharAt('foo', 2, 'b') == 'fob',
                   {msg: 'Board.replaceCharAt() is incorrect.'});
    console.assert(Board.replaceCharAt('foo', 0, 'ba') == 'boo',
                   {msg: 'Board.replaceCharAt() is incorrect.'});
    console.assert(Board.replaceCharAt('foo', 2, 'bar') == 'fob',
                   {msg: 'Board.replaceCharAt() is incorrect.'});

    let board = new Board(3, 4, 5, X_MARKER, O_MARKER);
    console.assert(board.width == 3,
                   {msg: 'board has wrong width.'});
    console.assert(board.height == 4,
                   {msg: 'board has wrong height.'});
    console.assert(board.length == 5,
                   {msg: 'board has wrong length.'});
    console.assert(board.playerMarker == X_MARKER,
                   {msg: 'board has wrong marker.'});
    console.assert(board.computerMarker == O_MARKER,
                   {msg: 'board has wrong marker.'});
    console.assert(!board.playerWin,
                   {msg: 'board unexpectedly done.'});
    console.assert(!board.computerWin,
                   {msg: 'board unexpectedly done.'});
    console.assert(!board.done,
                   {msg: 'board unexpectedly done.'});
    console.assert(board.cells == BLANK_MARKER.repeat(12),
                   {msg: 'board.cells not initialized.'});
    for (let x = -1; x <= board.width; x++) {
      for (let y = -1; y <= board.height; y++) {
        console.assert(board.get(x, y) == BLANK_MARKER,
                       {msg: 'board.get() is incorrect.'});
      }
    }
    console.assert(board.rows.length == 4,
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows.every(v => (v == BLANK_MARKER.repeat(3))),
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.columns.length == 3,
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns.every(v => (v == BLANK_MARKER.repeat(4))),
                   {msg: 'board.columns is incorrect.'});

    board = new Board(3, 3, 3, O_MARKER, X_MARKER);
    console.assert(board.width == 3,
                   {msg: 'board has wrong width.'});
    console.assert(board.height == 3,
                   {msg: 'board has wrong height.'});
    console.assert(board.length == 3,
                   {msg: 'board has wrong length.'});
    console.assert(board.playerMarker == O_MARKER,
                   {msg: 'board has wrong marker.'});
    console.assert(board.computerMarker == X_MARKER,
                   {msg: 'board has wrong marker.'});
    console.assert(!board.playerWin,
                   {msg: 'board unexpectedly done.'});
    console.assert(!board.computerWin,
                   {msg: 'board unexpectedly done.'});
    console.assert(!board.done,
                   {msg: 'board unexpectedly done.'});
    console.assert(board.cells == BLANK_MARKER.repeat(9),
                   {msg: 'board.cells not initialized.'});
    for (let x = -1; x <= board.width; x++) {
      for (let y = -1; y <= board.height; y++) {
        console.assert(board.get(x, y) == BLANK_MARKER,
                       {msg: 'board.get() is incorrect.'});
      }
    }
    console.assert(board.rows.length == 3,
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows.every(v => (v == BLANK_MARKER.repeat(3))),
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.columns.length == 3,
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns.every(v => (v == BLANK_MARKER.repeat(3))),
                   {msg: 'board.columns is incorrect.'});
    board.cells = Board.replaceCharAt(board.cells, 0, O_MARKER);
    board.cells = Board.replaceCharAt(board.cells, 4, X_MARKER);
    console.assert(board.cells == 'O   X    ',
                   {msg: 'board.cells is incorrect.'});
    for (let x = -1; x <= board.width; x++) {
      let expected = BLANK_MARKER;
      for (let y = -1; y <= board.height; y++) {
        if ((x == 0) && (y == 0)) {
          expected = O_MARKER;
        }
        else if ((x == 1) && (y == 1)) {
          expected = X_MARKER;
        }
        else {
          expected = BLANK_MARKER;
        }
        console.assert(board.get(x, y) == expected,
                       {msg: 'board.get() is incorrect.'});
      }
    }
    console.assert(board.rows.length == 3,
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[0] == 'O  ',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[1] == ' X ',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[2] == '   ',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.columns.length == 3,
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[0] == 'O  ',
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[1] == ' X ',
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[2] == '   ',
                   {msg: 'board.columns is incorrect.'});
    for (let [x, y, expected] of [
      [0, 0, 'OX '],
      [1, 0, '  '],
      [2, 0, ' '],
      [0, 1, '  '],
      [1, 1, 'OX '],
      [2, 1, '  '],
      [0, 2, ' '],
      [1, 2, '  '],
      [2, 2, 'OX ']]) {
      console.assert(board.getDiagonal(x, y) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
      console.assert(board.getDiagonal(x, y, false) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
    }
    for (let [x, y, expected] of [
      [0, 0, 'O'],
      [1, 0, '  '],
      [2, 0, ' X '],
      [0, 1, '  '],
      [1, 1, ' X '],
      [2, 1, '  '],
      [0, 2, ' X '],
      [1, 2, '  '],
      [2, 2, ' ']]) {
      console.assert(board.getDiagonal(x, y, true) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
    }
    console.assert(board.score(0, 0) == 0,
                   {msg: 'board.score() is incorrect.'});
    console.assert(board.score(1, 1) == 0,
                   {msg: 'board.score() is incorrect.'});
    console.assert(board.score(1, 0) == 11,
                   {msg: 'board.score() is incorrect.'});
    console.assert(board.score(2, 0) == 13,
                   {msg: 'board.score() is incorrect.'});
    console.assert(board.score(1, 2) == 12,
                   {msg: 'board.score() is incorrect.'});

    console.assert(board.mark(-1, 0, false) == board,
                   {msg: 'board.mark() is incorrect.'});
    console.assert(board.mark(0, 0, false) == board,
                   {msg: 'board.mark() is incorrect.'});
    console.assert(board.mark(0, -1, false) == board,
                   {msg: 'board.mark() is incorrect.'});
    console.assert(board.mark(1, 1, true) == board,
                   {msg: 'board.mark() is incorrect.'});
    console.assert(board.mark(board.width, 0, false) == board,
                   {msg: 'board.mark() is incorrect.'});
    console.assert(board.mark(0, board.height, false) == board,
                   {msg: 'board.mark() is incorrect.'});

    board = board.mark(2, 0, true);
    board = board.mark(0, 2, false);
    console.assert(!board.playerWin,
                   {msg: 'board unexpectedly done.'});
    console.assert(!board.computerWin,
                   {msg: 'board unexpectedly done.'});
    console.assert(!board.done,
                   {msg: 'board unexpectedly done.'});
    console.assert(board.cells == 'O X X O  ',
                   {msg: 'board.cells is incorrect.'});
    console.assert(board.rows.length == 3,
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[0] == 'O X',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[1] == ' X ',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[2] == 'O  ',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.columns.length == 3,
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[0] == 'O O',
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[1] == ' X ',
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[2] == 'X  ',
                   {msg: 'board.columns is incorrect.'});
    for (let [x, y, expected] of [
      [0, 0, 'OX '],
      [1, 0, '  '],
      [2, 0, 'X'],
      [0, 1, '  '],
      [1, 1, 'OX '],
      [2, 1, '  '],
      [0, 2, 'O'],
      [1, 2, '  '],
      [2, 2, 'OX ']]) {
      console.assert(board.getDiagonal(x, y) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
      console.assert(board.getDiagonal(x, y, false) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
    }
    for (let [x, y, expected] of [
      [0, 0, 'O'],
      [1, 0, '  '],
      [2, 0, 'XXO'],
      [0, 1, '  '],
      [1, 1, 'XXO'],
      [2, 1, '  '],
      [0, 2, 'XXO'],
      [1, 2, '  '],
      [2, 2, ' ']]) {
      console.assert(board.getDiagonal(x, y, true) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
    }

    board = board.mark(2, 1, true);
    board = board.mark(0, 1, false);
    console.assert(board.cells == 'O XOXXO  ',
                   {msg: 'board.cells is incorrect.'});
    console.assert(board.playerWin,
                   {msg: 'board unexpectedly not done.'});
    console.assert(!board.computerWin,
                   {msg: 'board unexpectedly not done.'});
    console.assert(board.done,
                   {msg: 'board unexpectedly not done.'});
    console.assert(board.rows.length == 3,
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[0] == 'O X',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[1] == 'OXX',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.rows[2] == 'O  ',
                   {msg: 'board.rows is incorrect.'});
    console.assert(board.columns.length == 3,
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[0] == 'OOO',
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[1] == ' X ',
                   {msg: 'board.columns is incorrect.'});
    console.assert(board.columns[2] == 'XX ',
                   {msg: 'board.columns is incorrect.'});
    for (let [x, y, expected] of [
      [0, 0, 'OX '],
      [1, 0, ' X'],
      [2, 0, 'X'],
      [0, 1, 'O '],
      [1, 1, 'OX '],
      [2, 1, ' X'],
      [0, 2, 'O'],
      [1, 2, 'O '],
      [2, 2, 'OX ']]) {
      console.assert(board.getDiagonal(x, y) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
      console.assert(board.getDiagonal(x, y, false) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
    }
    for (let [x, y, expected] of [
      [0, 0, 'O'],
      [1, 0, ' O'],
      [2, 0, 'XXO'],
      [0, 1, ' O'],
      [1, 1, 'XXO'],
      [2, 1, 'X '],
      [0, 2, 'XXO'],
      [1, 2, 'X '],
      [2, 2, ' ']]) {
      console.assert(board.getDiagonal(x, y, true) == expected,
                     {msg: 'board.getDiagonal() is incorrect.'});
    }
  }
}
Board.test();

class Display {
  constructor(parent, marker) {
    if (!(parent instanceof Node)) {
      throw new TypeError('Bad DOM parent.');
    }
    this.parent = parent;

    if (!(marker instanceof Node)) {
      throw new TypeError('Bad DOM parent.');
    }
    this.marker = marker;
  }
  draw(board) {
    this.marker.innerHTML = `Player: <span class="${board.playerMarker}">${board.playerMarker}</span> Computer: <span class="${board.computerMarker}">${board.computerMarker}</span>`;
  }
}

class ASCIIDisplay extends Display {
  draw(board) {
    super.draw(board);
    let target = this.parent.querySelector('pre');
    if (target == null) {
      this.parent.innerHTML = '';
      target = document.createElement('pre');
      this.parent.appendChild(target);
    }
    target.textContent = board.rows.join('\n');
  }
}

class CanvasDisplay extends Display {
  draw(board) {
    super.draw(board);
    let target = this.parent.querySelector('canvas');
    if (target == null) {
      this.parent.innerHTML = '';
      target = document.createElement('canvas');
      this.parent.appendChild(target);
    }
    let width = board.width * SCALE,
        height = board.height * SCALE,
        middle = SCALE / 2;
    if ((target.width != width) || (target.height != height)) {
      target.width = width;
      target.height = height;
    }

    let context = target.getContext('2d');
    context.clearRect(0, 0, width, height);

    context.lineWidth = 5;
    for (let y = 0; y < board.height; y++) {
      for (let x = 0; x < board.width; x++) {
        let marker = board.get(x, y);
        if (marker == X_MARKER) {
          context.strokeStyle = '#0000FF';
          context.beginPath();
          context.moveTo((x * SCALE) + 5, (y * SCALE) + 5);
          context.lineTo(((x + 1) * SCALE) - 5, ((y + 1) * SCALE) - 5);
          context.moveTo(((x + 1) * SCALE) - 5, (y * SCALE) + 5);
          context.lineTo((x * SCALE) + 5, ((y + 1) * SCALE) - 5);
          context.stroke();
        }
        if (marker == O_MARKER) {
          context.strokeStyle = '#FF0000';
          context.beginPath();
          context.arc((x * SCALE) + middle, (y * SCALE) + middle, middle - 5, 0, 2 * Math.PI);
          context.stroke();
        }
      }
    }

    // Draw grid lines
    context.lineWidth = 1;
    context.strokeStyle = '#000000';
    for (let x = 1; x < board.width; x++) {
      context.beginPath();
      context.moveTo(x * SCALE, 0);
      context.lineTo(x * SCALE, height);
      context.stroke();
    }
    for (let y = 1; y < board.height; y++) {
      context.beginPath();
      context.moveTo(0, y * SCALE);
      context.lineTo(width, y * SCALE);
      context.stroke();
    }
  }
}

class TableDisplay extends Display {
  draw(board) {
    super.draw(board);
    let target = this.parent.querySelector('table');
    if (target == null) {
      this.parent.innerHTML = '';
      target = document.createElement('table');
      this.parent.appendChild(target);
    }

    let rows = [];
    for (let y = 0; y < board.height; y++) {
      let row = [];
      row.push('  <tr>');
      for (let x = 0; x < board.width; x++) {
        let marker = board.get(x, y);
        row.push(`    <td class="${marker}">${marker}</td>`);
      }
      row.push('  </tr>');
      rows.push(row.join('\n'));
    }
    target.innerHTML = rows.join('\n');
  }
}

let output = document.querySelector('#board');
let marker = document.querySelector('#marker');
let size = document.querySelector('#size');
//let display = new ASCIIDisplay(output, marker);
let display = new CanvasDisplay(output, marker);
//let display = new TableDisplay(output, marker);

let board = null;
function newBoard(event) {
  if (Math.random() < 0.5) {
    board = new Board(size.value, size.value, size.value, X_MARKER, O_MARKER);
  }
  else {
    // Computer makes the first move
    board = new Board(size.value, size.value, size.value, O_MARKER, X_MARKER);
    board = board.computerMove();
  }
  display.draw(board);
}

size.addEventListener('change', newBoard);
output.addEventListener('click', (event) => {
  let box = output.getBoundingClientRect(),
      x = Math.min(Math.floor((event.clientX - box.left) / SCALE), board.width - 1),
      y = Math.min(Math.floor((event.clientY - box.top) / SCALE), board.height - 1),
      previous = board;
  if (x < 0) {
    x = 0;
  }
  if (y < 0) {
    y = 0;
  }
  board = board.mark(x, y);
  if (board != previous) {
    // If the player actually changed the board (didn't click on an occupied square)
    board = board.computerMove();

    display.draw(board);
    if (board.playerWin) {
      alert('You won!');
    }
    else if (board.computerWin) {
      alert('You lost!');
    }
    else if (board.done) {
      alert('You tied.');
    }
  }
});
document.querySelector('#new').addEventListener('click', newBoard);

newBoard();
</script>
</body>

</html>
